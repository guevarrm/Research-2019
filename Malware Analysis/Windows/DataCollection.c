/*
  @author Michael Guevarra guevarrm@myumanitoba.ca
  @desc Takes snapshot of system processes and modules and exports information
        into a MySQL database.
  @required
          MySQL server - MySQLMichaelPC
          Compiler instructions:
          -llibmysql for mysql connection
          -lrpcrt4 for UuidCreate
          -lpsapi for process memory
*/

#include <stdio.h>
#include <sys/stat.h>
#include <time.h>

#include <C:\Program Files\MySQL\MySQL Connector C 6.1\include\mysql.h> // MySQL

// includes required for process and module snapshots
#include <windows.h>
#include <tlhelp32.h>
#include <tchar.h>

//includes for process memory information
#include <psapi.h>


// Forward definitions
void finish_with_error(MYSQL *con); // MySQL error handling
void printError( TCHAR* msg ); // Process Tree error handling
void GetData( int loopNum, MYSQL *con); // Process tree data acquisition
void GetModules(DWORD pid, int loopNum, MYSQL *con, char* sUuid,
                int modtHb, int modtLb ); // Module data from process

/*
  @desc Sets up MySQL connection and tables for process/module data then
        iterates to record n snapshots of data
*/
int main() {
  MYSQL *con; // MySQL server connection
  MYSQL_RES *res; // MySQL results
  MYSQL_ROW row; // Single MySQL row

  // MySQL connection properties
  char *server = "localhost"; // server name
  char *user = "vmachine"; // username
  char *password = "engineer"; // password
  char *database = "processdata"; // assume database exists and attach to it

  con = mysql_init(NULL);

  // Connect to database
  if (!mysql_real_connect(con, server, user, password, database, 0, NULL, 0 )){
    finish_with_error(con);
  }//if

  printf("\nConnected to MySQL server.");

  // Create table for process data
  if (mysql_query(con, "DROP TABLE IF EXISTS process")) {
  finish_with_error(con);
  }//if table exists, replace

  if (mysql_query(con, "CREATE TABLE process(LoopNum INT,"
                                            " UUID Char(37),"
                                            " PID INT, PRN VARCHAR(150),"
                                            " PRT BIGINT, PPID INT,"
                                            " PRM BIGINT, THC INT,"
                                            " PRIMARY KEY (UUID))")) {
    finish_with_error(con);
  }//if

  printf("\n'process' table created.");

  // Create table for module data
  if (mysql_query(con, "DROP TABLE IF EXISTS module")) {
  finish_with_error(con);
  }//if table exists, replace
  if (mysql_query(con, "CREATE TABLE module(LoopNum INT,"
                                            " UUID Char(37), PID INT,"
                                            " MODN VARCHAR(150), MODT BIGINT,"
                                            " MODL VARCHAR(150), MODM BIGINT)"
                                            )) {
    finish_with_error(con);
  }//if
  printf("\n'module' table created.");

  // Begin data capture
  int i;
  for(i=1; i<=5; i++)
  {
    double total_time;  // timestamp
	  clock_t start, end;
	  start = clock();

    GetData(i, con); // single iteration of data capture

    // Calculating total time taken by the program.
    end = clock();
	  //time count stops
	  total_time = ((double) (end - start)) / CLK_TCK;
	  //calulate total time
	  printf("\nTime taken for process: %f s", total_time);
  }//for

  return 0;
}//main()

/*
  @desc A single iteration of data capture which takes a snapshot of all running
        processes then grabs information for each one by one. For each process,
        the information on the related modules are also iterated through.
  @param int loopNum  - current iteration number
         MYSQL *con   - pointer to MYSQL connection
*/
void GetData(int loopNum, MYSQL *con)
{
  HANDLE hProcessSnap; // pointer to all running processes
  HANDLE hProcess; // handle for one specific process
  PROCESSENTRY32 pe32; // data structure for process information
  PROCESS_MEMORY_COUNTERS pmc; // data structure for process memory

  int pid; // Process ID
  char* prn; // Process Name
  int prtHb = 0; // Process Create Time
  int prtLb = 0;
  int ppid; // Parent Process ID
  int prm; // Process Memory Size
  int thc; // Thread Count

  // Take a snapshot of all processes in the system (TH32CS_SNAPPROCESS).
  hProcessSnap = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );
  if( hProcessSnap == INVALID_HANDLE_VALUE ) // error handling
  {
    printError( TEXT("CreateToolhelp32Snapshot (of processes)") );
    return;
  }

  // Set the size of the structure before using it. Required for initialization
  pe32.dwSize = sizeof( PROCESSENTRY32 );

  // Retrieve information about the first process, and exit if unsuccessful
  if( !Process32First( hProcessSnap, &pe32 ) )
  {
    printError( TEXT("Process32First") ); // show cause of failure
    CloseHandle( hProcessSnap );          // clean the snapshot object
    return;
  }//if

  // Now walk the snapshot of processes, and
  // display information about each process in turn
  do
  {
    pid = pe32.th32ProcessID; // Process ID
    prn = pe32.szExeFile; // Process name
    ppid = pe32.th32ParentProcessID; // Parent Process ID
    thc = pe32.cntThreads; // Thread Count

    UUID Uuid; // Unique identifier for MySQL
    unsigned char* sUuid; // String representation of Uuid
    UuidCreate(&Uuid);
    UuidToString(&Uuid, &sUuid);

    // get more detailed process info through openProcess
    hProcess = OpenProcess(  PROCESS_QUERY_INFORMATION |
                                    PROCESS_VM_READ,
                                    FALSE, pe32.th32ProcessID );
    if (hProcess)
      {
        //get creation time
        FILETIME lpCreationTime, lpExitTime, lpKernelTime, lpUserTime;
        SYSTEMTIME sysCreationTime, sysExitTime, sysKernelTime, sysUserTime;

        if ( GetProcessTimes( hProcess, &lpCreationTime, &lpExitTime,
                              &lpKernelTime, &lpUserTime))
        {
          FileTimeToSystemTime( &lpCreationTime, &sysCreationTime );
          prtLb = lpCreationTime.dwLowDateTime;
          prtHb = lpCreationTime.dwHighDateTime;
        }//if

        // get memory info
        if ( GetProcessMemoryInfo( hProcess, &pmc, sizeof(pmc)) )
        {
          char buffer[75];
          prm = pmc.WorkingSetSize;
        }//if

        CloseHandle (hProcessSnap);
      }//if

      //send to MySQL database
      char sendValues[100];
      sprintf(sendValues, "INSERT INTO process VALUES( %i, '%s', %i, '%s'"
                          ", %i%i, %i, %i, %i)", loopNum, sUuid, pid, prn,
                          prtHb, prtLb, ppid, prm, thc);

      if (mysql_query(con, sendValues)){
        finish_with_error(con);
      }//if

      GetModules( pe32.th32ProcessID, loopNum, con, sUuid, prtHb, prtLb ); // Access associated modules

  } while ( Process32Next( hProcessSnap, &pe32 ) ); // iterate through processes

}//GetData()

/*
  @desc Similar to GetData, iterate through a snapshot of modules relating to
        a particular process and record data in a MySQL database
  @params DWORD pid   - Process ID which modules are associated to
          int loopNum - Current iteration number
          MYSQL *con  - Pointer to MySQL connection
          char* sUuid - Unique identifier of attached process
          int modtHb  - High bit of module create time
          int modtLb  - Low bit of module create time
*/
void GetModules(DWORD pid, int loopNum, MYSQL *con, char* sUuid, int modtHb, int modtLb)
{
  HANDLE hModuleSnap = INVALID_HANDLE_VALUE; // pointer to all spawned modules
  MODULEENTRY32 me32; // data structure for module information

  char* modn; // Module name
  char* modl; // Module location
  int modm; // Module memory size

  // Take a snapshot of all modules in the specified process.
  hModuleSnap = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, pid );
  if( hModuleSnap == INVALID_HANDLE_VALUE )
  {
    //printError( TEXT("CreateToolhelp32Snapshot (of modules)") ); ** Reveals priviledge restricted access
    return;
  }

  // Set the size of the structure before using it. Required for initialization
  me32.dwSize = sizeof( MODULEENTRY32 );

  // Retrieve information about the first module, and exit if unsuccessful
  if( !Module32First( hModuleSnap, &me32 ) )
  {
    //printError( TEXT("Module32First") );  // show cause of failure
    CloseHandle( hModuleSnap );           // clean the snapshot object
    return;
  }

  // Now walk the module list of the process,
  // and display information about each module
  do
  {
    //printf( "\n\n     MODULE NAME:     %s",   me32.szModule );
    modn = me32.szModule;
    modl = me32.szExePath;
    modm = me32.modBaseSize;

    char sendValues[100];
    sprintf(sendValues, "INSERT INTO module VALUES( %i, '%s', %i, '%s', %i%i, '%s', %i)", loopNum, sUuid, pid, modn, modtHb, modtLb, modl, modm);
    if (mysql_query(con, sendValues)){
      finish_with_error(con);
    }//if

  } while ( Module32Next( hModuleSnap, &me32 ) ); // iterate through modules

  CloseHandle( hModuleSnap );
  return;

}//GetModules()

/*
  @desc Error handling for MySQL requests
*/
void finish_with_error(MYSQL *con)
{
  fprintf(stderr, "%s\n", mysql_error(con));
  mysql_close(con);
  exit(1);
}//finish_with_error()

/*
  @desc Error handling for process tree monitoring
*/
void printError( TCHAR* msg )
{
  DWORD eNum;
  TCHAR sysMsg[256];
  TCHAR* p;

  eNum = GetLastError( );
  FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
         NULL, eNum,
         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
         sysMsg, 256, NULL );

  // Trim the end of the line and terminate it with a null
  p = sysMsg;
  while( ( *p > 31 ) || ( *p == 9 ) )
    ++p;
  do { *p-- = 0; } while( ( p >= sysMsg ) &&
                          ( ( *p == '.' ) || ( *p < 33 ) ) );

  // Display the message
  _tprintf( TEXT("\n  WARNING: %s failed with error %d (%s)"), msg, eNum, sysMsg );
}//printError()
